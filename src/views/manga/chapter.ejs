<div class="min-h-screen bg-primary-900">
    <!-- Reader Header -->
    <header id="readerHeader"
        class="fixed top-0 left-0 right-0 z-50 bg-primary-900/80 backdrop-blur-lg border-b border-purple-500/20 transition-transform duration-300">
        <div class="container mx-auto px-4 py-3">
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between space-y-2 sm:space-y-0">
                <div class="flex items-center space-x-4">
                    <a href="https://www.komikkuya.my.id/<%= navigation.mangaDetailUrl || 'javascript:history.back()' %>"
                        class="text-gray-400 hover:text-white transition-colors">
                        <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </a>
                    <div>
                        <h1 class="text-lg sm:text-xl font-bold text-white truncate max-w-[200px] sm:max-w-xs">
                            <%= chapter.mangaTitle %>
                        </h1>
                        <p class="text-xs sm:text-sm text-gray-400 truncate max-w-[200px] sm:max-w-xs">
                            <%= chapter.title %>
                        </p>
                    </div>
                </div>
                <div class="flex items-center justify-between sm:justify-end space-x-2 sm:space-x-4">
                    <div class="flex items-center bg-primary-800 rounded-lg p-1">
                        <% if (navigation.prev && navigation.prev.url) { %>
                            <a href="<%= navigation.prev.url %>"
                                class="p-1.5 sm:p-2 text-gray-400 hover:text-white hover:bg-primary-700 rounded-lg transition-all"
                                title="<%= navigation.prev.title %>">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M15 19l-7-7 7-7" />
                                </svg>
                            </a>
                            <% } else { %>
                                <button class="p-1.5 sm:p-2 text-gray-600 cursor-not-allowed rounded-lg" disabled>
                                    <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M15 19l-7-7 7-7" />
                                    </svg>
                                </button>
                                <% } %>
                                    <span class="px-2 sm:px-3 text-xs sm:text-sm text-gray-400">
                                        Ch.<%= navigation.currentChapter %>
                                            <% if ((navigation.prev && navigation.prev.url) || (navigation.next &&
                                                navigation.next.url)) { %>
                                                <span class="text-gray-600">/</span>
                                                <% if (navigation.prev && navigation.prev.url) { %>
                                                    <span class="text-purple-400">
                                                        <%= navigation.prevChapter %>
                                                    </span>
                                                    <% } %>
                                                        <% if (navigation.next && navigation.next.url) { %>
                                                            <span class="text-purple-400">
                                                                <%= navigation.nextChapter %>
                                                            </span>
                                                            <% } %>
                                                                <% } %>
                                    </span>
                                    <% if (navigation.next && navigation.next.url) { %>
                                        <a href="<%= navigation.next.url %>"
                                            class="p-1.5 sm:p-2 text-gray-400 hover:text-white hover:bg-primary-700 rounded-lg transition-all"
                                            title="<%= navigation.next.title %>">
                                            <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M9 5l7 7-7 7" />
                                            </svg>
                                        </a>
                                        <% } else { %>
                                            <button class="p-1.5 sm:p-2 text-gray-600 cursor-not-allowed rounded-lg"
                                                disabled>
                                                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor"
                                                    viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        stroke-width="2" d="M9 5l7 7-7 7" />
                                                </svg>
                                            </button>
                                            <% } %>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Progress Bar -->
    <div id="readingProgress" class="fixed top-0 left-0 right-0 h-1 bg-primary-800 z-50">
        <div id="progressBar" class="h-full bg-purple-500 transition-all duration-300" style="width: 0%"></div>
    </div>

    <!-- Reader Content -->
    <main class="container mx-auto px-2 sm:px-4 pt-20 sm:pt-24 pb-16 sm:pb-12">
        <div class="max-w-4xl mx-auto">
            <% chapter.images.forEach((image, index)=> { %>
                <div class="relative group mb-0" id="page-<%= index + 1 %>">
                    <img data-src="/manga/image/<%= Buffer.from(image.url).toString('base64') %>"
                        src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                        alt="<%= image.alt || `Page ${index + 1}` %>"
                        class="w-full rounded-none shadow-none image-enhance" loading="lazy"
                        width="<%= image.width || 'auto' %>" height="<%= image.height || 'auto' %>"
                        onerror="this.onerror=null; this.src='<%= image.url %>';">
                    <div
                        class="absolute bottom-2 sm:bottom-4 right-2 sm:right-4 bg-black/50 text-white px-2 sm:px-3 py-0.5 sm:py-1 rounded-lg text-xs sm:text-sm opacity-0 group-hover:opacity-100 transition-opacity">
                        Page <%= index + 1 %>
                    </div>
                </div>
                <% }); %>
        </div>
    </main>

    <!-- Reader Footer -->
    <footer id="readerFooter"
        class="fixed bottom-0 left-0 right-0 z-50 bg-primary-900/80 backdrop-blur-lg border-t border-purple-500/20 transition-transform duration-300">
        <div class="container mx-auto px-4 py-3">
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between space-y-2 sm:space-y-0">
                <div class="text-xs sm:text-sm text-gray-400">
                    Released: <%= new Date(chapter.releaseDate).toLocaleDateString() %>
                </div>
                <div class="flex items-center justify-between sm:justify-end space-x-2 sm:space-x-4">
                    <div class="flex items-center space-x-2">
                        <button id="toggleReadingMode"
                            class="px-3 py-1.5 sm:px-4 sm:py-2 bg-primary-800 text-white text-xs sm:text-sm rounded-lg hover:bg-primary-700 transition-colors">
                            Toggle Reading Mode
                        </button>
                        <button id="toggleHeaderFooter"
                            class="px-3 py-1.5 sm:px-4 sm:py-2 bg-primary-800 text-white text-xs sm:text-sm rounded-lg hover:bg-primary-700 transition-colors flex items-center">
                            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 6h16M4 12h16M4 18h16" />
                            </svg>
                            <span>Hide UI</span>
                        </button>
                        <div class="hidden sm:flex items-center space-x-2 bg-primary-800 rounded-lg px-3 py-2">
                            <span class="text-xs sm:text-sm text-gray-400">Speed:</span>
                            <input type="range" id="scrollSpeed" min="1" max="10" value="5"
                                class="w-16 sm:w-24 h-1.5 sm:h-2 bg-primary-700 rounded-lg appearance-none cursor-pointer">
                            <span id="speedValue" class="text-xs sm:text-sm text-white">5x</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Mobile Speed Control -->
            <div class="sm:hidden mt-2 flex items-center justify-between">
                <span class="text-xs text-gray-400">Scroll Speed:</span>
                <div class="flex items-center space-x-2">
                    <input type="range" id="mobileScrollSpeed" min="1" max="10" value="5"
                        class="w-24 h-1.5 bg-primary-700 rounded-lg appearance-none cursor-pointer">
                    <span id="mobileSpeedValue" class="text-xs text-white">5x</span>
                </div>
            </div>
        </div>
    </footer>

    <!-- Floating Controls -->
    <div id="floatingControls"
        class="fixed right-4 bottom-20 z-50 flex flex-col space-y-2 opacity-0 transition-opacity duration-300">
        <button id="floatingToggleHeaderFooter"
            class="bg-primary-800 text-white p-2 rounded-full shadow-lg hover:bg-primary-700 transition-colors"
            title="Show UI">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
        </button>
    </div>
</div>

<style>
    .image-enhance {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        transform: translateZ(0);
        filter: contrast(1.1) brightness(1.08) saturate(1.15) blur(0.2px);
        will-change: transform;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    /* Add a subtle sharpening effect */
    .image-enhance::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to bottom,
                rgba(255, 255, 255, 0.05) 0%,
                rgba(255, 255, 255, 0) 100%);
        pointer-events: none;
    }

    /* Custom range input styling */
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 8px;
        background: #4B5563;
        border-radius: 4px;
        outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: #9333EA;
        border-radius: 50%;
        cursor: pointer;
        transition: background 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
        background: #A855F7;
    }

    input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #9333EA;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        transition: background 0.2s;
    }

    input[type="range"]::-moz-range-thumb:hover {
        background: #A855F7;
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
        input[type="range"] {
            height: 6px;
        }

        input[type="range"]::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
        }
    }

    /* Header/Footer hidden state */
    .header-hidden {
        transform: translateY(-100%);
    }

    .footer-hidden {
        transform: translateY(100%);
    }

    /* Floating controls visible state */
    .controls-visible {
        opacity: 1;
    }

    /* Progress bar styling */
    #readingProgress {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    #progressBar {
        box-shadow: 0 0 5px rgba(147, 51, 234, 0.5);
    }
</style>

<script>
    // Reading mode toggle and auto-scroll
    const toggleReadingMode = document.getElementById('toggleReadingMode');
    const scrollSpeed = document.getElementById('scrollSpeed');
    const mobileScrollSpeed = document.getElementById('mobileScrollSpeed');
    const speedValue = document.getElementById('speedValue');
    const mobileSpeedValue = document.getElementById('mobileSpeedValue');
    const mainContent = document.querySelector('main');
    const readerHeader = document.getElementById('readerHeader');
    const readerFooter = document.getElementById('readerFooter');
    const floatingControls = document.getElementById('floatingControls');
    const toggleHeaderFooter = document.getElementById('toggleHeaderFooter');
    const floatingToggleHeaderFooter = document.getElementById('floatingToggleHeaderFooter');
    const progressBar = document.getElementById('progressBar');

    let isReadingMode = false;
    let autoScrollInterval = null;
    let currentSpeed = 5;
    let lastScrollTime = 0;
    let scrollPosition = 0;
    let isHeaderFooterVisible = true;
    let inactivityTimer = null;
    let lastUserActivity = Date.now();
    let totalPages = <%= chapter.images.length %>;
    let currentPage = 1;
    let pagePositions = [];
    let loadedImages = new Set();
    let preloadQueue = [];
    let isPreloading = false;

    // Save reading history to localStorage
    function saveToHistory() {
        try {
            // Get current history or initialize empty array
            const history = JSON.parse(localStorage.getItem('readingHistory') || '[]');

            // Create history item
            const historyItem = {
                title: '<%= chapter.mangaTitle %>',
                chapterTitle: '<%= chapter.title %>',
                url: window.location.pathname,
                image: '<%= chapter.images && chapter.images.length > 0 ? chapter.images[0].url : "" %>',
                lastRead: new Date().toISOString(),
                totalPages: <%= chapter.images.length %>,
                readPages: currentPage,
                chapterId: '<%= chapter.id || "" %>',
                mangaId: '<%= chapter.mangaId || "" %>'
            };

            // Check if this manga is already in history
            const existingIndex = history.findIndex(item =>
                item.title === historyItem.title &&
                item.chapterId === historyItem.chapterId
            );

            if (existingIndex !== -1) {
                // Update existing entry
                history[existingIndex] = historyItem;
            } else {
                // Add new entry
                history.push(historyItem);
            }

            // Keep only the last 50 entries
            if (history.length > 50) {
                history.splice(0, history.length - 50);
            }

            // Save back to localStorage
            localStorage.setItem('readingHistory', JSON.stringify(history));

            // Also save detailed reading progress
            saveReadingProgress();
        } catch (error) {
            console.error('Error saving to history:', error);
        }
    }

    // Save detailed reading progress
    function saveReadingProgress() {
        try {
            const mangaId = '<%= chapter.mangaId || "" %>';
            const chapterId = '<%= chapter.id || "" %>';

            if (!mangaId || !chapterId) return;

            // Get existing progress or initialize empty object
            const progress = JSON.parse(localStorage.getItem('readingProgress') || '{}');

            // Initialize manga progress if it doesn't exist
            if (!progress[mangaId]) {
                progress[mangaId] = {
                    title: '<%= chapter.mangaTitle %>',
                    chapters: {}
                };
            }

            // Update chapter progress
            progress[mangaId].chapters[chapterId] = {
                title: '<%= chapter.title %>',
                totalPages: <%= chapter.images.length %>,
                readPages: currentPage,
                lastRead: new Date().toISOString()
            };

            // Save back to localStorage
            localStorage.setItem('readingProgress', JSON.stringify(progress));
        } catch (error) {
            console.error('Error saving reading progress:', error);
        }
    }

    // Sync mobile and desktop speed controls
    function syncSpeedControls() {
        const isMobile = window.innerWidth < 640;
        const activeControl = isMobile ? mobileScrollSpeed : scrollSpeed;
        const activeDisplay = isMobile ? mobileSpeedValue : speedValue;

        currentSpeed = parseInt(activeControl.value);
        speedValue.textContent = `${currentSpeed}x`;
        mobileSpeedValue.textContent = `${currentSpeed}x`;

        // Restart auto-scroll with new speed if active
        if (autoScrollInterval) {
            clearInterval(autoScrollInterval);
            startAutoScroll();
        }
    }

    // Update speed display
    scrollSpeed.addEventListener('input', syncSpeedControls);
    mobileScrollSpeed.addEventListener('input', syncSpeedControls);

    // Smooth scroll function using requestAnimationFrame
    function smoothScroll() {
        const now = performance.now();
        const elapsed = now - lastScrollTime;
        lastScrollTime = now;

        // Calculate scroll amount based on elapsed time and speed
        const baseSpeed = 30; // Reduced base speed for smoother scrolling
        const scrollAmount = (baseSpeed * currentSpeed / 5) * (elapsed / 16.67); // Normalize to 60fps

        scrollPosition += scrollAmount;

        // Only scroll if we have a whole pixel to scroll
        if (scrollPosition >= 1) {
            const pixelsToScroll = Math.floor(scrollPosition);
            window.scrollBy(0, pixelsToScroll);
            scrollPosition -= pixelsToScroll;
        }

        // Check if we've reached the bottom
        if (window.innerHeight + window.scrollY >= document.documentElement.scrollHeight) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
            toggleReadingMode.textContent = 'Start Auto-Scroll';
            isReadingMode = false;
            return;
        }

        // Continue scrolling
        if (autoScrollInterval) {
            requestAnimationFrame(smoothScroll);
        }
    }

    // Start auto-scroll
    function startAutoScroll() {
        lastScrollTime = performance.now();
        scrollPosition = 0;
        autoScrollInterval = setInterval(() => {
            requestAnimationFrame(smoothScroll);
        }, 16); // Approximately 60fps
    }

    // Toggle reading mode and auto-scroll
    toggleReadingMode.addEventListener('click', () => {
        isReadingMode = !isReadingMode;

        if (isReadingMode) {
            // Start auto-scroll
            toggleReadingMode.textContent = 'Stop Auto-Scroll';
            startAutoScroll();
        } else {
            // Stop auto-scroll
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }

            toggleReadingMode.textContent = 'Start Auto-Scroll';
        }
    });

    // Toggle header and footer visibility
    function toggleUI() {
        isHeaderFooterVisible = !isHeaderFooterVisible;

        if (isHeaderFooterVisible) {
            readerHeader.classList.remove('header-hidden');
            readerFooter.classList.remove('footer-hidden');
            floatingControls.classList.remove('controls-visible');
            toggleHeaderFooter.innerHTML = '<svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg><span>Hide UI</span>';
        } else {
            readerHeader.classList.add('header-hidden');
            readerFooter.classList.add('footer-hidden');
            floatingControls.classList.add('controls-visible');
            toggleHeaderFooter.innerHTML = '<svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg><span>Show UI</span>';
        }

        // Reset inactivity timer
        resetInactivityTimer();
    }

    toggleHeaderFooter.addEventListener('click', toggleUI);
    floatingToggleHeaderFooter.addEventListener('click', toggleUI);

    // Auto-hide header and footer after inactivity
    function resetInactivityTimer() {
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(() => {
            if (isHeaderFooterVisible) {
                readerHeader.classList.add('header-hidden');
                readerFooter.classList.add('footer-hidden');
                floatingControls.classList.add('controls-visible');
                isHeaderFooterVisible = false;
                toggleHeaderFooter.innerHTML = '<svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg><span>Show UI</span>';
            }
        }, 3000); // Hide after 3 seconds of inactivity
    }

    // Track user activity
    function trackUserActivity(event) {
        lastUserActivity = Date.now();

        // Only show UI on keyboard input, not on mouse movement, touch, or scroll
        if (!isHeaderFooterVisible && event && event.type === 'keydown') {
            readerHeader.classList.remove('header-hidden');
            readerFooter.classList.remove('footer-hidden');
            floatingControls.classList.remove('controls-visible');
            isHeaderFooterVisible = true;
            toggleHeaderFooter.innerHTML = '<svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg><span>Hide UI</span>';
            resetInactivityTimer();
        }
    }

    // Add event listeners for user activity
    document.addEventListener('keydown', trackUserActivity);

    // Handle window resize
    window.addEventListener('resize', () => {
        // Sync speed controls when switching between mobile and desktop views
        syncSpeedControls();
        // Recalculate page positions
        calculatePagePositions();
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft' && document.querySelector('a[href*="prev"]')) {
            window.location.href = document.querySelector('a[href*="prev"]').href;
        } else if (e.key === 'ArrowRight' && document.querySelector('a[href*="next"]')) {
            window.location.href = document.querySelector('a[href*="next"]').href;
        } else if (e.key === ' ' || e.key === 'Enter') {
            // Toggle auto-scroll with space or enter
            e.preventDefault();
            toggleReadingMode.click();
        } else if (e.key === 'h') {
            // Toggle header/footer with 'h' key
            toggleUI();
        }
    });

    // Calculate page positions for progress tracking
    function calculatePagePositions() {
        pagePositions = [];
        const pages = document.querySelectorAll('[id^="page-"]');

        pages.forEach((page, index) => {
            const rect = page.getBoundingClientRect();
            const pageTop = rect.top + window.scrollY;
            const pageBottom = pageTop + rect.height;
            const pageMiddle = pageTop + (rect.height / 2);

            pagePositions.push({
                top: pageTop,
                bottom: pageBottom,
                middle: pageMiddle,
                index: index + 1
            });
        });
    }

    // Update reading progress
    function updateReadingProgress() {
        if (pagePositions.length === 0) return;

        const viewportTop = window.scrollY;
        const viewportBottom = viewportTop + window.innerHeight;
        const viewportMiddle = viewportTop + (window.innerHeight / 2);

        // Find the page that's most visible in the viewport
        let visiblePages = [];

        for (let i = 0; i < pagePositions.length; i++) {
            const page = pagePositions[i];

            // Calculate how much of the page is visible
            const visibleTop = Math.max(page.top, viewportTop);
            const visibleBottom = Math.min(page.bottom, viewportBottom);
            const visibleHeight = Math.max(0, visibleBottom - visibleTop);
            const visibilityPercentage = (visibleHeight / page.bottom) * 100;

            if (visibilityPercentage > 0) {
                visiblePages.push({
                    index: page.index,
                    visibility: visibilityPercentage
                });
            }
        }

        // If no pages are visible, find the closest page
        if (visiblePages.length === 0) {
            let closestPage = pagePositions[0];
            let minDistance = Math.abs(viewportMiddle - pagePositions[0].middle);

            for (let i = 1; i < pagePositions.length; i++) {
                const distance = Math.abs(viewportMiddle - pagePositions[i].middle);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPage = pagePositions[i];
                }
            }

            currentPage = closestPage.index;
        } else {
            // Sort by visibility percentage
            visiblePages.sort((a, b) => b.visibility - a.visibility);
            currentPage = visiblePages[0].index;
        }

        // Check if we're at the last page
        const isLastPage = currentPage === totalPages;

        // Calculate progress percentage
        let progress;
        if (isLastPage) {
            // If we're at the last page, set progress to 100%
            progress = 100;
        } else {
            // Otherwise, calculate based on current page
            progress = Math.min(100, (currentPage / totalPages) * 100);
        }

        // Update progress bar
        progressBar.style.width = `${progress}%`;

        // Preload adjacent images based on current page
        preloadAdjacentImages(currentPage);
    }

    // Preload adjacent images
    function preloadAdjacentImages(currentPageIndex) {
        // Preload next 2 pages
        for (let i = 1; i <= 2; i++) {
            const nextPageIndex = currentPageIndex + i;
            if (nextPageIndex <= totalPages) {
                addToPreloadQueue(nextPageIndex);
            }
        }

        // Preload previous page if not already loaded
        const prevPageIndex = currentPageIndex - 1;
        if (prevPageIndex >= 1) {
            addToPreloadQueue(prevPageIndex);
        }

        // Start preloading if not already in progress
        if (!isPreloading && preloadQueue.length > 0) {
            processPreloadQueue();
        }
    }

    // Add image to preload queue
    function addToPreloadQueue(pageIndex) {
        if (!loadedImages.has(pageIndex) && !preloadQueue.includes(pageIndex)) {
            preloadQueue.push(pageIndex);
        }
    }

    // Add encryption/decryption functions
    function decryptImageUrl(encryptedUrl, key) {
        try {
            // Use a more secure decryption method
            const decodedUrl = atob(encryptedUrl.replace(/-/g, '+').replace(/_/g, '/'));
            // Add additional security by XORing with the key
            const keyBytes = new TextEncoder().encode(key);
            const urlBytes = new TextEncoder().encode(decodedUrl);
            const decryptedBytes = new Uint8Array(urlBytes.length);

            for (let i = 0; i < urlBytes.length; i++) {
                decryptedBytes[i] = urlBytes[i] ^ keyBytes[i % keyBytes.length];
            }

            return new TextDecoder().decode(decryptedBytes);
        } catch (e) {
            console.error('Error decrypting URL:', e);
            return encryptedUrl;
        }
    }

    // Modify the preload function to handle encrypted URLs
    function processPreloadQueue() {
        if (preloadQueue.length === 0) {
            isPreloading = false;
            return;
        }

        isPreloading = true;
        const pageIndex = preloadQueue.shift();
        const img = document.querySelector(`#page-${pageIndex} img`);

        if (img && img.dataset.src) {
            const encryptedUrl = img.dataset.src;
            const encryptionKey = img.dataset.key || 'default-key';
            const imageUrl = img.dataset.encrypted === 'true' ? decryptImageUrl(encryptedUrl, encryptionKey) : encryptedUrl;

            // Create a new image object to preload
            const preloadImg = new Image();
            preloadImg.onload = function () {
                // Once loaded, update the actual image
                img.src = imageUrl;
                img.removeAttribute('data-src');
                img.removeAttribute('data-encrypted');
                img.removeAttribute('data-key');
                loadedImages.add(pageIndex);

                // Continue processing queue
                setTimeout(() => {
                    processPreloadQueue();
                }, 50);
            };

            preloadImg.onerror = function () {
                console.error('Failed to load image:', pageIndex);
                loadedImages.delete(pageIndex);
                setTimeout(() => {
                    processPreloadQueue();
                }, 50);
            };

            preloadImg.src = imageUrl;
        } else {
            setTimeout(() => {
                processPreloadQueue();
            }, 50);
        }
    }

    // Lazy loading images with improved performance
    document.addEventListener('DOMContentLoaded', () => {
        // Save to history when page loads
        saveToHistory();

        // Initialize speed controls
        syncSpeedControls();

        // Start inactivity timer
        resetInactivityTimer();

        // Calculate page positions for progress tracking
        calculatePagePositions();

        // Add scroll event listener for progress tracking
        window.addEventListener('scroll', updateReadingProgress);

        // Save progress when user leaves the page
        window.addEventListener('beforeunload', saveToHistory);

        // Initial progress update
        updateReadingProgress();

        // Preload first few images immediately
        for (let i = 1; i <= Math.min(3, totalPages); i++) {
            addToPreloadQueue(i);
        }

        // Start preloading
        processPreloadQueue();

        // Set up intersection observer for lazy loading
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const pageId = img.closest('[id^="page-"]').id;
                    const pageIndex = parseInt(pageId.replace('page-', ''));

                    if (img.dataset.src && !loadedImages.has(pageIndex)) {
                        addToPreloadQueue(pageIndex);
                        if (!isPreloading) {
                            processPreloadQueue();
                        }
                    }

                    observer.unobserve(img);
                }
            });
        }, {
            rootMargin: '200px 0px', // Increased margin to start loading earlier
            threshold: 0.1
        });

        // Observe all images
        document.querySelectorAll('img[data-src]').forEach(img => {
            imageObserver.observe(img);
        });
    });
</script>